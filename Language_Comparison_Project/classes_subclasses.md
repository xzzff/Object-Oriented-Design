# Overview
Here we discuss how Cpp and Java compare with regards to classes, subclasses, and how each manages constructor delegating/chaining, destructors, and static variable.

In terms of class definitions and to refer to an instance of an object of a class (using `this`), both languages are very similar. With Cpp, one has much more explicit control over destructors and managing the scope and lifetime of objects. 

We do not discuss this explicitly later on, but Cpp allows you to have default parameter values in methods (including constructors), whereas Java does not. Java accomplishes this purely via method overloading. 

Static works a bit differently between the two languages. Notably, Java does not support static local variables and Cpp gives you a bit more flexibility with declarations of static variable with incomplete type within a class definition to be filled later on. There is also more control over resolution in internal vs external linkage with the `static` keyword in Cpp.

# Classes

In Cpp, one can use the class type specifier followed by an identifier, curly braces, and a semicolon to declare a class. For example, to explicitly declare a class with a constructor, destructor, and member variable, see below.

```cpp
class Person
{
  public:
    // Constructor
    Person(std::string n) : name(n)
    {
    }
    
    // Destructor
    ~Person()
     {
       // Destruct dynamic memory here and do clean-up if need be.
     }
  private:
    std::string name;
};
```
Note that we could have written the constructor more like a Java-style like this:
```cpp
class Person
{
  public:
    Person(std::string n)
    {
      this->name = n;
    }

  private:
    std::string name;
};
```

In Java, the same example is below.

```java
  public class Person
  {
    private String name;

    public Person(String n)
    {
      this->name = n;
    }
  }
```

### Constructors
Both languages have a default, no-arg constructor generated by the compiler if no constructor is defined. This is what will be called if you try to construct an object of a class without defining a constructor for the class.

In Cpp, when a non-POD object is instantiated, a constructor of that class must be invoked. In the case of POD objects, there is no such guarantee. 

```cpp
struct Pod
{
  int x;
};
```

What is interesting to note is some odd cases in Java where a class may be constructed without its constructor being called.
* During deserialization, Serialisable classes do not have their constructor called. The no-arg constructor of most derived non-serialisable is invoked only by the serialisation mechanism. This is implementation dependent and is typically found in non-verifiable bytecode in fact.
* When `Object.clone()` is called. One can get around this by implementing their own class though and overriding the clone method.

### Destructors
Note in particular that we have explicit control over destructors and memory management in Cpp, whereas we do not really have that obtion in Java due to garbage collection. While one can certainly use the `finalize()` method directly in Java, it is best practice not to as they are not a reliable resource clean up and can cause problems in the garbage collector by abusing them. If one needs a deallocation call in an object, say to release resources, you can use an explicit method call. Notably, this is seen in the Closeable API for example; this is typically called with `try/finally` as seen below. This is known as the Dispose pattern in other garbage collection languages.

```java
  Resource r = new Resource();
  try
  {
    // Do some work
  }
  finally
  {
    // Get rid of resource
    r.dispose();
  }
```

### How instance of an object is referenced in a class
Both languages use the `this` keyword to accomplish this. This is seen in the first Cpp example under the Classes section for the constructor. However, in the general concensus in the Cpp communitity it to note use `this->`.

# Subclasses
Subclasses come up very often by nature and are represented by inheritance. Since we have discussed this in detail in a previous post with access control, we leave it at that. Instead, we discuss constructors, constructor chaining, and destructors when it comes to subclasses.

### Constructors
The notion of constructor chaining occurs most notably during inheritance. A subclass constructor's first job is to call its superclass' constructor. This forces the creation of the subclass object to start with the initialization of classes above it in the inheritance chain. Some examples with subclasses and constructor chaining are given below.

```cpp
class Base
{
  public:
    Base(int x)
    {
      // Do something with x here
    }
};

class Derived : public Base
{
  public:
    Derived(int x, int y) 
      : Base(x), // Call base constructor in the derived class constructor
      foo(y)     // Set member variable foo in Derived class with value of y
    {
    }
  private:
    int foo;
};
```

In Java, one can use the 'this' keyword to call a constructor *within the same class* and the `super` keyword to call the constructor *of the Parent class*. Note that `super` needs to be the first line in the body of a constructor method.

```java
class Parent
{
  private String name;

  public Parent()
  {
  }

  public Parent(String n)
  {
    this.name = n;
  }
}

public class Child extends Parent
{
  public Child(String name)
  {
    super(name);
    // Do more stuff in child constructor after calling parent
  }
}
```

To utilize other constructors within the same class, a few examples can be found below.

This is known as Delegating Constructors which is similar to the  notion of calling constructors from other constructors in Java. It is actually a recent  Cpp-11 addition. Previously, in Cpp-03, people would mimic similar behavior to call constructors by making the method that delegates a non-constructor. For example, if you look at older APIs, that is why you see things like `init()`, `cleanup()`, etc. This is similar behavior as in C APIs as well.

```cpp
class Foo
{
  public:
    Foo(char x, int y)
    {
    }
    Foo(int y) : Foo('a', y) // Calls other constructor above with two args.
    {
    }
}
```

In Java, this is accomplished via overriding since you can have multiple constructors as long as the parameter list of types is different. Note that the `super` keyword still must be the first statement in your constructor body if you are using it to invoke another constructor.

```java
public class Foo
{
  private double width;
  private double height;

  Foo(double x)
  {
    // Calls two-arg constructor after invoking calculateHeight method
    this(width, calculateHeight(width));
  }
  Foo(double x, double y)
  {
    this.width = x;
    this.height = y;
  }

  private static double calculateHeight(final double width)
  {
    return 2*width;
    // Could have more complex logic most certainly
  }
}
```

# Static 
With Cpp, the keyword `static` declares members that are not bound to a particular class instance. Outside of a class definition, it has a different meaning known as static storage duration. This has more to do with internal linkage for LTO purposes of a compiler and determining what is valid when compiling multiple translation units. That is beyond the scope of this language comparison project, so we omit the details.

The syntax and examples are shown below. They are taken from [CppReference](http://en.cppreference.com/w/cpp/language/static).

1. `static` *data_member*
2. `static` *member_funtion*

```cpp
class X
{
  static int n;
};
```

In particular, the declaration inside a class body is not a definition and can even declare members to be of incomplete type. For example:

```cpp
struct Foo; // forward declare
struct X
{
  static int a[]; // declaration and incomplete type
  static Foo x; // declaration and incomplete type
  static S s; // declaration and incomplete type (despite being inside own definition)
};

int S::a[10]; // definiton and complete type now that we specified the compile-time size of the array
struct Foo {};
Foo S::x; // definition and complete type
S S::s; //definition and complete type
```

Recall that in inheritance with Cpp, static members of a base class are also static members of any derived class. They will each share the same instance of that static variable, rather than having their own copy. For example, with the example program below, the value of the `total` variable would be 4 since the construction of the `Derived` class would cause the `total` to be incremented twice. This is due to the Derived class constructor calling the Base class constructor.

```cpp
class Base
{
  public:
    Base() { total++; }
    static int total;
};
int Base::total = 0;

class Derived : public Base
{
  public:
    Derived() { total++; }
};

int main(int argc, char** argv)
{
  Base a;
  Base b;
  Derived c;
  // Here, the value of total would be 4
  return 0;
}
```

In Java, static variables in Java are not inherited. They exist only in the class which declares them. Note that public or protected member variables (static or not) are visible in all subclasses of the Base class. Unlike Cpp, Java does not support static local variables. However, unlike Cpp, Java does support static blocks which are useful for static initialization of a class.
