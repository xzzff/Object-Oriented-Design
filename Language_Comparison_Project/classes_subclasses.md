# Overview
TODO

# Classes

In Cpp, one can use the class type specifier followed by an identifier, curly braces, and a semicolon to declare a class. For example, to explicitly declare a class with a constructor, destructor, and member variable, see below.

```cpp
class Person
{
  public:
    // Constructor
    Person(std::string n) : name(n)
    {
    }
    
    // Destructor
    ~Person()
     {
       // Destruct dynamic memory here and do clean-up if need be.
     }
  private:
    std::string name;
};
```
Note that we could have written the constructor more like a Java-style like this:
```cpp
class Person
{
  public:
    Person(std::string n)
    {
      this->name = n;
    }

  private:
    std::string name;
};
```

In Java, the same example is below.

```java
  public class Person
  {
    private String name;

    public Person(String n)
    {
      this->name = n;
    }
  }
```

### Constructors
Both languages have a default, no-arg constructor generated by the compiler if no constructor is defined. This is what will be called if you try to construct an object of a class without defining a constructor for the class.

In Cpp, when a non-POD object is instantiated, a constructor of that class must be invoked. In the case of POD objects, there is no such guarantee. 

```cpp
struct Pod
{
  int x;
};
```

What is interesting to note is some odd cases in Java where a class may be constructed without its constructor being called.
* During deserialization, Serialisable classes do not have their constructor called. The no-arg constructor of most derived non-serialisable is invoked only by the serialisation mechanism. This is implementation dependent and is typically found in non-verifiable bytecode in fact.
* When `Object.clone()` is called. One can get around this by implementing their own class though and overriding the clone method.

### Destructors
Note in particular that we have explicit control over destructors and memory management in Cpp, whereas we do not really have that obtion in Java due to garbage collection. While one can certainly use the `finalize()` method directly in Java, it is best practice not to as they are not a reliable resource clean up and can cause problems in the garbage collector by abusing them. If one needs a deallocation call in an object, say to release resources, you can use an explicit method call. Notably, this is seen in the Closeable API for example; this is typically called with `try/finally` as seen below. This is known as the Dispose pattern in other garbage collection languages.

```java
  Resource r = new Resource();
  try
  {
    // Do some work
  }
  finally
  {
    // Get rid of resource
    r.dispose();
  }
```

### How instance of an object is referenced in a class
Both languages use the `this` keyword to accomplish this. This is seen in the first Cpp example under the Classes section for the constructor. However, in the general concensus in the Cpp communitity it to note use `this->`.

# Subclasses
Subclasses come up very often by nature and are represented by inheritance. Since we have discussed this in detail in a previous post with access control, we leave it at that. Instead, we discuss constructors, constructor chaining, and destructors when it comes to subclasses.

### Constructors
The notion of constructor chaining occurs most notably during inheritance. A subclass constructor's first job is to call its superclass' constructor. This forces the creation of the subclass object to start with the initialization of classes above it in the inheritance chain. Some examples with subclasses and constructor chaining are given below.

```cpp
class Base
{
  public:
    Base(int x)
    {
      // Do something with x here
    }
};

class Derived : public Base
{
  public:
    Derived(int x, int y) 
      : Base(x), // Call base constructor in the derived class constructor
      foo(y)     // Set member variable foo in Derived class with value of y
    {
    }
  private:
    int foo;
};
```

In Java, one can use the 'this' keyword to call a constructor *within the same class* and the `super` keyword to call the constructor *of the Parent class*. Note that `super` needs to be the first line in the body of a constructor method.

```java
class Parent
{
  private String name;

  public Parent()
  {
  }

  public Parent(String n)
  {
    this.name = n;
  }
}

public class Child extends Parent
{
  public Child(String name)
  {
    super(name);
    // Do more stuff in child constructor after calling parent
  }
}
```

To utilize other constructors within the same class, a few examples can be found below.

This is known as Delegating Constructors which is similar to the  notion of calling constructors from other constructors in Java. It is actually a recent  Cpp-11 addition. Previously, in Cpp-03, people would mimic similar behavior to call constructors by making the method that delegates a non-constructor. For example, if you look at older APIs, that is why you see things like `init()`, `cleanup()`, etc. This is similar behavior as in C APIs as well.

```cpp
class Foo
{
  public:
    Foo(char x, int y)
    {
    }
    Foo(int y) : Foo('a', y) // Calls other constructor above with two args.
    {
    }
}
```

In Java, this is accomplished via overriding since you can have multiple constructors as long as the parameter list of types is different. Note that the `super` keyword still must be the first statement in your constructor body if you are using it to invoke another constructor.

```java
public class Foo
{
  private double width;
  private double height;

  Foo(double x)
  {
    // Calls two-arg constructor after invoking calculateHeight method
    this(width, calculateHeight(width));
  }
  Foo(double x, double y)
  {
    this.width = x;
    this.height = y;
  }

  private static double calculateHeight(final double width)
  {
    return 2*width;
    // Could have more complex logic most certainly
  }
}
```

# Static 
TODO - Discuss static member variable usage