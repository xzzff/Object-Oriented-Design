# Overview
TODO

# Classes

In Cpp, one can use the class type specifier followed by an identifier, curly braces, and a semicolon to declare a class. For example, to explicitly declare a class with a constructor, destructor, and member variable, see below.

```cpp
class Person
{
  public:
    // Constructor
    Person(std::string n) : name(n)
    {
    }
    /* Alternate constructor
    Person(std::string n)
    {
      this->name = n;
    }
    */
    
    // Destructor
    ~Person()
     {
       // Destruct dynamic memory here and do clean-up if need be.
     }
  std::string name;
};
```
In Java, the same example is below.

```java
  public class Person
  {
    private String name;

    public Person(String name)
    {
      this->name = name;
    }
  }
```

### Constructors
Both languages have a default, no-arg constructor generated by the compiler if no constructor is defined. This is what will be called if you try to construct an object of a class without defining a constructor for the class.

In Cpp, when a non-POD object is instantiated, a constructor of that class must be invoked. In the case of POD objects, there is no such guarantee. 

```cpp
struct Pod
{
  int x;
};
```

What is interesting to note is some odd cases in Java where a class may be constructed without its constructor being called.
* During deserialization, Serialisable classes do not have their constructor called. The no-arg constructor of most derived non-serialisable is invoked only by the serialisation mechanism. This is implementation dependent and is typically found in non-verifiable bytecode in fact.
* When `Object.clone()` is called. One can get around this by implementing their own class though and overriding the clone method.

### Destructors
Note in particular that we have explicit control over destructors and memory management in Cpp, whereas we do not really have that obtion in Java due to garbage collection. While one can certainly use the `finalize()` method directly in Java, it is best practice not to as they are not a reliable resource clean up and can cause problems in the garbage collector by abusing them. If one needs a deallocation call in an object, say to release resources, you can use an explicit method call. Notably, this is seen in the Closeable API for example; this is typically called with `try/finally` as seen below. This is known as the Dispose pattern in other garbage collection languages.

```java
  Resource r = new Resource();
  try
  {
    // Do some work
  }
  finally
  {
    // Get rid of resource
    r.dispose();
  }
```

### How instance of an object is referenced in a class
Both languages use the `this` keyword to accomplish this. This is seen in the first Cpp example under the Classes section for the constructor. However, in the general concensus in the Cpp communitity it to note use `this->`.

# Subclasses

### Constructors
TODO: How constructors can utilize other constructors

# Static 